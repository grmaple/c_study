# 带你学C带你飞

## 27常量和指针

#### 指向常量的指针

`const int num = 800;`

`const int *p = &num;`

- 指针可以修改为指向不同的常量
- 指针可以修改为指向不同的变量
- 可以通过解引用来读取指针指向的数据
- 不可以通过接引用修改指针指向的数据

#### 常量指针

指向非常量的常量指针

`int num = 520;`

`int * const p = &num;`'

- 指针自身不可以被修改
- 指针指向的值可以被修改

指向常量的常量指针

`const int cnum = 520;`

`const int * const p = &num;`

- 指针自身不可以被修改
- 指针指向的值也不可以被修改

#### 指向”指向常量的常量指针“的指针

`const int cnum = 520;`

`const int * const p = &num;`

`const int * const *pp = &p;`

## 28函数

#### 函数的定义

`void printc(){pass;}`

#### 函数的声明

`void printc();`

#### 函数的参数和返回值

## 29参数和指针

#### 参数和返回值

#### 形参和实参

#### 传值和传址

- 传值

  `void swap(int x, int y)`

  `swap(x,y);`

  函数修改了参数，但是main函数没有修改。因为局部变量的原因。

- 传址

  `void swap(int *x, int *y)`

  `sway(&x,&y)`

  函数修改了参数，main函数也修改了。因为使用的是同一个地址。

  数组参数，是传了数组的首地址，相当于传址，

#### 可变参数

`#include <stdarg>`

`-va_list`可变参数列表 

`-va_start`初始化可变参数

`-va_arg`获取可变参数的值

`-va_end`清除可变参数

```
int sum(int n, ...);
int sum(int n, ...)
{
	int i, sum = 0;
	va_list vap;
	va_start(vap, n);
	for(i = 0; i < n; i++)
	{
		sum += va_arg(vap, int);
	}
	ve_ent(vap);
	return sum;
}
```

## 30指针函数和函数指针

#### 指针函数

`char *getWord(char);`

使用指针变量作为函数的返回值

#### 不要返回局部变量的指针

#### 函数指针

指向函数的指针

`int (*fp)()` 

#### 函数指针作为参数

```
int add(int, int);
int sub(int, int);
int calc(int (*fp)(int, int), int int);
calc(add, 3, 5);
```

#### 函数指针作为返回值

```
int (*select(char op))(int, int);
char op;
int (*fp)(int)(int);
fp = select(op);
calc(fp, 3, 5);
```

31

## 31局部变量和全局变量

#### 不同函数的变量无法相互访问

#### 复合语句

#### 全局变量

在函数里面定义的：局部变量

在函数外面定义的：全局变量

如果不对全局变量进行初始化，会自动初始化为0

函数内部存在一个与全局变量同名的局部变量，编辑器不会报错，而是再函数中屏蔽全局变量

#### extern关键字

用extern关键字告诉编译器，这个变量我在后面定义了，先别急着报错。

#### 不要大量的使用全局变量

- 使用全局变量会使你的程序占用更多的内存，因为全局变量从被定义开始，直到程序退出才被释放
- 污染命名空间，虽然局部变量会屏蔽全局变量，但是这样降低了程序的可读性
- 提高了程序的耦合性，牵一发而动全身

## 32作用域和链接属性

#### 作用域

当变量被定义在程序的不同位置时，它的作用范围的不一样的，这个作用范围就是作用域

- 代码块作用域
- 文件作用域
- 原型作用域
- 函数作用域

##### 代码块作用域(局部变量)

在代码块中定义的变量，具有代码块作用域。

作用范围是从变量定义的位置开始，到标志该代码块结束的}处

尽管函数的形参不在大括号内定义，但原因具有代码块作用域

##### 文件作用域(全局变量)

任何在代码块之外声明的标识符都具有文件作用域。

作用范围是从它们声明的位置开始，到文件的结尾处都是可以访问的

函数名也有文件作用域

##### 原型作用域

原型作用域置适用于那些在函数原型中声明的参数名

##### 函数作用域

函数作用域只适用于goto语句的标签，作用将goto语句的标签限制在同一个函数内部，以防止出现同名标签

#### 定义和声明

![image-20200417223248985](E:\Desktop\image-20200417223248985.png)

#### 链接属性

- external(外部的)

多个文件中声明的同名标识符表示同一个实体

- internal(内部的)

单个文件中声明的同名标识符表示同一个实体

- none(无)

声明的同名标识符被当作独立不同的实体



只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性

默认情况下，具备文件作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。



使用static关键字可以使得原先拥有external属性的标识符变成internal属性

- 使用static关键字修改链接属性，只对具有文件作用域的标识符生效(可以保护标识符)
- 链接属性只能修改一次

## 33生成期和存储类型

#### 生存期

##### 静态存储期

具有文件作用域的变量属于静态存储期，函数也属于静态存储期。属于静态存储期的变量在程序执行期间将一直占据存储空间，直到程序关闭才释放。

##### 自动存储期

具有代码块作用域的变量一般情况下属于自动存储期。属于自动存储期的变量在代码块结束时将自动释放存储空间。

#### 存储类型

存储类型其实是指存储变量值的内存类型

auto，register，static，extern，typedef

##### 自动变量auto

在代码块中声明的变量默认的存储类型是自动变量

##### 寄存器变量register

该变量有可能被存放在cpu的寄存器中

寄存器变量和自动变量都拥有代码块作用域，自动存储区和空链接属性。

无法通过取值操作符获得地址

##### 静态局部变量static

使用static来声明局部变量，可以将局部变量指定为静态局部变量，拥有静态存储期，生存期和全局变量一样，但是作用域不变

##### static和extern

