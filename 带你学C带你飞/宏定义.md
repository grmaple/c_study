## 宏定义

三大预处理功能

宏定义

文件包含

条件编译

编译器工作流程

预处理	生成.i文件

编译	生成.s汇编语言文件

汇编	生成.o目标文件

链接	生成可执行文件

### 宏定义

只做简单替换，不做计算，不做表达式求解

##### 不带参数的宏定义

#define PI 3.14

编译才做语法检查。编译器不会对宏定义做语法检查

宏定义作用域是从定义位置到整个程序结束，

可以用#undef终止宏定义的作用域

宏定义允许嵌套

##### 带参数的宏定义

#define MAX(x, y) ((x) > (y) ? (x) : (y))

类似函数但不是函数，只是简单的替换。

不用写参数类型。

防止意外bug，尽量用括号括起来。

使用自增自减运算符时容易出错。 

入栈顺序是从右到左

### 内联函数

解决程序中函数调用的效率问题

内联函数会像宏定义一样展开，但是没有宏定义那些bug。

```c
#include <stdio.h>
inline int square(int x) {
    return x * x;
}
int main() {
    int i = 1;
    while (i <= 100) {
        printf("%d的平方是%d\n", i-1, square(i++));
    }
}
```

内联函数嵌入调用者代码中的操作是一种优化操作，只有优化编译(-O)时才有效。否则只是普通函数。

![image-20200827201915839](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200827201915839.png)

内联函数虽然节省了函数调用的时间消耗，但是也因此增加了代码编译的时间。

并不是所有函数都能够变成内联函数。

### #和##

#参数	预处理器会把整个参数转换为一个字符串(加双引号)。

参数1##参数2	预处理器会将两个字符连接起来

\##就是个粘合剂，将前后两部分粘合起来，也就是有“字符化”的意思。但是“##”不能随意粘合任意字符，必须是合法的C语言标示符。在单一的宏定义中，最多可以出现一次“#”或“##”预处理操作符。如果没有指定与“#”或“##”预处理操作符相关的计算次序，则会产生问题。为避免该问题，在单一的宏定义中只能使用其中一种操作符(即，一份“#”或一个“##”，或都不用)。除非非常有必要，否则尽量不要使用“#”和“##”。

### 可变参数

#define SHOWLIST(...) printf(#__VA_ARGS\_\_)

...表示使用可变参数，__VA_ARGS\_\_在预处理中被实际的参数集所替换

...被表示成零个或多个符号，包括里面的逗号，一直到到右括弧结束为止.

```c
#include <stdio.h>
#define SHOWLIST(...) printf(#__VA_ARGS__)
#define PRINT(format, ...) printf(#format, ##__VA_ARGS__)
int main() {
    SHOWLIST(i, love, 1314\n);
    //printf("i, love, 1314\n");
    PRINT(num = %d\n, 520);
    //printf("num = %d\n",520);
    PRINT(Hello World!\n);//可变参数是空参数
    //printf("Hello World!\n");
    return 0;
}

```

**##__VA_ARGS\_\_** **宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的","去掉的作用,否则会编译出错**

